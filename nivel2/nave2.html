<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nivel normal</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            pointer-events: none;
            text-shadow: 0 0 5px #fff, 0 0 10px #fff;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            text-shadow: 0 0 5px #fff, 0 0 10px #fff;
        }

        /* Efectos para los power-ups */
        .powerup-effect {
            position: absolute;
            width: 100px;
            height: 100px;
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            transition: all 0.5s ease-out;
        }

        /* Estilos para el escudo activo */
        .escudo-activo {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 3px dashed rgba(0, 200, 255, 0.7);
            box-shadow: 0 0 15px 5px rgba(0, 200, 255, 0.5);
            pointer-events: none;
            z-index: 90;
            animation: escudo-pulse 2s infinite;
        }

        @keyframes escudo-pulse {
            0% { transform: scale(0.95); opacity: 0.8; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(0.95); opacity: 0.8; }
        }

        /* Indicador de power-up activo */
        .powerup-indicator {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-left: 5px;
            vertical-align: middle;
        }

        /* Estilo para el texto de power-up activo */
        #powerup-status {
            font-weight: bold;
            text-shadow: 0 0 5px currentColor;
        }
    </style>
</head>

<body>
    <div id="game-container"></div>

    <div class="loading">Cargando nave espacial...</div>

    <div id="ui">
        Puntuación: <span id="score">0</span><br>
        Vidas: <span id="lives">3</span><br>
        Power-up: <span id="powerup-status">Ninguno</span>
    </div>

    <!-- Three.js y GLTFLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Para el texto en los power-ups -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/geometries/TextGeometry.js"></script>

    <script>
        // Variables del juego
        let scene, camera, renderer;
        let nave, meteoritos = [];
        let score = 0;
        let lives = 3;
        let gameOver = false;
        let meteoritoSpeed = 0.05;
        let spawnInterval = 1500; // ms
        let lastSpawnTime = 0;
        let loader = new THREE.GLTFLoader();
        let proyectiles = [];
        let proyectilSpeed = 0.5;
        let keysPressed = {};
        const disparoAudio = new Audio('../Audios/disparo.mp3');
        let powerups = [];
        let hasShield = false;
        let isRapidFire = false;
        let rapidFireInterval = null;
        let shieldMesh = null;
        let font = null;

        // Inicializar el juego
        function initGame() {
            // Escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000020);

            // Cámara en vista superior (ortográfica)
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = 15;
            camera = new THREE.OrthographicCamera(
                -viewSize * aspect / 2,
                viewSize * aspect / 2,
                viewSize / 2,
                -viewSize / 2,
                0.1,
                1000
            );
            camera.position.set(0, 20, 0);
            camera.lookAt(0, 0, 0);
            camera.rotation.x = -Math.PI / 2; // Mira directamente hacia abajo

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Luces
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(0, 10, 0);
            scene.add(light);

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            // Cargar fuente para los textos
            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.132.2/examples/fonts/helvetiker_regular.typeface.json', function(loadedFont) {
                font = loadedFont;
                cargarNave();
            });

            // Eventos
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            // Iniciar generación de power-ups
            setInterval(crearPowerUp, 10000); // uno nuevo cada 10s
        }

        // ===== CARGAR NAVE =====
        function cargarNave() {
            loader.load(
                '../nivel1/Nave_03.glb',
                function (gltf) {
                    nave = gltf.scene;
                    // Ajustes para vista superior
                    nave.rotation.x = 0; // No rotar en X
                    nave.rotation.set(Math.PI, 0, 0); // 180° en X y Z

                    nave.position.set(0, 0, 0);
                    nave.scale.set(0.2, 0.2, 0.2);
                    scene.add(nave);
                    cargarAlien();
                    scene.background = new THREE.Color(0x0f0f3d);

                    document.querySelector('.loading').style.display = 'none';

                    iniciarJuego();
                },
                undefined,
                function (error) {
                    console.error('Error al cargar la nave:', error);
                    document.querySelector('.loading').textContent = 'Error al cargar la nave.';
                }
            );
        }

        // ===== CARGAR METEORITO =====
        function cargarMeteorito() {
            loader.load(
                '../nivel1/meteorito1.glb',
                function (gltf) {
                    const meteorito = gltf.scene;

                    // Posición aleatoria en los bordes
                    let x, z;
                    if (Math.random() > 0.5) {
                        x = (Math.random() - 0.5) * 20;
                        z = Math.random() > 0.5 ? 10 : -10;
                    } else {
                        x = Math.random() > 0.5 ? 10 : -10;
                        z = (Math.random() - 0.5) * 20;
                    }

                    meteorito.position.set(x, 0, z);

                    // Escala aleatoria
                    const scale = 0.5 + Math.random() * 0.7;
                    meteorito.scale.set(scale, scale, scale);

                    // Vector hacia el centro
                    const centerVector = new THREE.Vector3(-x, 0, -z).normalize();

                    // Vector aleatorio pequeño
                    const randomAngle = (Math.random() - 0.5) * Math.PI / 3; // +-30 grados
                    // Rotar el vector centerVector en Y (plano XZ)
                    const cosA = Math.cos(randomAngle);
                    const sinA = Math.sin(randomAngle);

                    const direction = new THREE.Vector3(
                        centerVector.x * cosA - centerVector.z * sinA,
                        0,
                        centerVector.x * sinA + centerVector.z * cosA
                    ).normalize();

                    meteorito.userData = {
                        speed: meteoritoSpeed + Math.random() * 0.03,
                        direction: direction
                    };

                    scene.add(meteorito);
                    meteoritos.push(meteorito);
                },
                undefined,
                function (error) {
                    console.error('Error al cargar meteorito:', error);
                }
            );
        }

        function cargarMeteorito2() {
            loader.load(
                'meteorito2.glb',
                function (gltf) {
                    const meteorito = gltf.scene;

                    // Posición aleatoria en los bordes
                    let x, z;
                    if (Math.random() > 0.5) {
                        x = (Math.random() - 0.5) * 20;
                        z = Math.random() > 0.5 ? 10 : -10;
                    } else {
                        x = Math.random() > 0.5 ? 10 : -10;
                        z = (Math.random() - 0.5) * 20;
                    }

                    meteorito.position.set(x, 0, z);

                    // Escala aleatoria
                    const scale = 0.5 + Math.random() * 0.7;
                    meteorito.scale.set(scale, scale, scale);

                    // Vector hacia el centro
                    const centerVector = new THREE.Vector3(-x, 0, -z).normalize();

                    // Vector aleatorio pequeño
                    const randomAngle = (Math.random() - 0.5) * Math.PI / 3; // +-30 grados
                    // Rotar el vector centerVector en Y (plano XZ)
                    const cosA = Math.cos(randomAngle);
                    const sinA = Math.sin(randomAngle);

                    const direction = new THREE.Vector3(
                        centerVector.x * cosA - centerVector.z * sinA,
                        0,
                        centerVector.x * sinA + centerVector.z * cosA
                    ).normalize();

                    meteorito.userData = {
                        speed: meteoritoSpeed + Math.random() * 0.03,
                        direction: direction
                    };

                    scene.add(meteorito);
                    meteoritos.push(meteorito);
                },
                undefined,
                function (error) {
                    console.error('Error al cargar meteorito:', error);
                }
            );
        }

        // ===== CARGAR ALIEN =====
        function cargarAlien() {
            loader.load(
                'alien.glb',
                function (gltf) {
                    alien = gltf.scene;
                    alien.rotation.y = Math.PI; // Girarlo para que mire hacia la cámara si es necesario

                    // Cambiar posición más abajo a la derecha
                    alien.position.set(7, 2, -5); // x a los lados, y altura, z abajo

                    // Hacerlo más pequeño
                    alien.scale.set(0.1, 0.1, 0.1); // Reducir tamaño

                    scene.add(alien);
                },
                undefined,
                function (error) {
                    console.error('Error al cargar el alien:', error);
                }
            );
        }

        // ===== DISPARAR =====
        function dispararProyectil() {
            if (!nave || gameOver) return;

            // Crear una esfera simple para el proyectil
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const proyectil = new THREE.Mesh(geometry, material);

            // Posición inicial justo delante de la nave
            proyectil.position.set(nave.position.x, 0.1, nave.position.z - 1);
            scene.add(proyectil);

            // Guardamos el proyectil con su velocidad y dirección (hacia arriba en z negativo)
            proyectil.userData = {
                speed: proyectilSpeed,
                direction: new THREE.Vector3(0, 0, -1)
            };

            proyectiles.push(proyectil);
            if (disparoAudio) {
                disparoAudio.currentTime = 0;
                disparoAudio.play();
            }
        }

        // ===== POWERUPS =====
        function crearPowerUp() {
            if (gameOver) return;

            const tipos = ['rapido', 'escudo', 'bomba'];
            const tipo = tipos[Math.floor(Math.random() * tipos.length)];
            let color, emoji;

            switch (tipo) {
                case 'rapido':
                    color = 0xFFD700; // Oro
                    emoji = '⚡';
                    break;
                case 'escudo':
                    color = 0x00BFFF; // Azul cielo
                    emoji = '🛡️';
                    break;
                case 'bomba':
                    color = 0xFF4500; // Rojo anaranjado
                    emoji = '💣';
                    break;
                default:
                    color = 0x00FF00; // Verde
                    emoji = '❓';
            }

            // Crear geometría del power-up
            const geometry = new THREE.SphereGeometry(0.5, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            
            const powerup = new THREE.Mesh(geometry, material);
            
            // Añadir texto (emoji) al power-up si la fuente está cargada
            if (font) {
                const textGeometry = new THREE.TextGeometry(emoji, {
                    size: 0.5,
                    height: 0.1,
                    font: font
                });
                const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.set(0, 0, 0.6);
                powerup.add(textMesh);
            }

            // Posición aleatoria
            const x = (Math.random() - 0.5) * 18;
            const z = (Math.random() - 0.5) * 18;
            powerup.position.set(x, 0.5, z);

            // Animación de flotación
            powerup.userData = {
                tipo: tipo,
                tiempoRecogida: 0,
                floatOffset: Math.random() * Math.PI * 2,
                originalY: 0.5
            };

            scene.add(powerup);
            powerups.push(powerup);

            // Eliminar después de 10 segundos
            setTimeout(() => {
                if (powerups.includes(powerup)) {
                    scene.remove(powerup);
                    powerups = powerups.filter(p => p !== powerup);
                }
            }, 10000);
        }

        function detectarColisionPowerUps() {
            if (!nave || powerups.length === 0) return;

            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                const distance = nave.position.distanceTo(powerup.position);

                if (distance < 1.0) { // Radio de colisión
                    // Aplicar efecto del power-up
                    aplicarPowerUp(powerup.userData.tipo);
                    
                    // Eliminar power-up de la escena
                    scene.remove(powerup);
                    powerups.splice(i, 1);
                }
            }
        }

        function aplicarPowerUp(tipo) {
            // Mostrar en UI
            const powerupStatus = document.getElementById('powerup-status');
            powerupStatus.textContent = tipo.charAt(0).toUpperCase() + tipo.slice(1);
            powerupStatus.style.color = {
                'rapido': '#FFD700',
                'escudo': '#00BFFF',
                'bomba': '#FF4500'
            }[tipo];

            // Crear efecto visual de recogida
            const effect = document.createElement('div');
            effect.className = 'powerup-effect';
            effect.style.background = `radial-gradient(circle, rgba(255,255,255,0.8) 0%, ${
                {
                    'rapido': 'rgba(255,215,0,0) 70%',
                    'escudo': 'rgba(0,191,255,0) 70%',
                    'bomba': 'rgba(255,69,0,0) 70%'
                }[tipo]
            }`;
            effect.style.left = `${window.innerWidth/2 - 50}px`;
            effect.style.top = `${window.innerHeight/2 - 50}px`;
            effect.style.borderRadius = '50%';
            effect.style.opacity = '1';
            document.body.appendChild(effect);

            setTimeout(() => {
                effect.style.transform = 'scale(2)';
                effect.style.opacity = '0';
                setTimeout(() => effect.remove(), 500);
            }, 10);

            // Aplicar efecto del power-up
            switch (tipo) {
                case 'rapido':
                    activarDisparoRapido();
                    break;
                case 'escudo':
                    activarEscudo();
                    break;
                case 'bomba':
                    eliminarMeteoritos();
                    break;
            }

            // Resetear el estado después de 5 segundos
            setTimeout(() => {
                powerupStatus.textContent = 'Ninguno';
                powerupStatus.style.color = 'white';
            }, 5000);
        }

        function eliminarMeteoritos() {
            for (let i = meteoritos.length - 1; i >= 0; i--) {
                scene.remove(meteoritos[i]);
                meteoritos.splice(i, 1);
                score += 2; // Bonus por eliminar con bomba
            }
            document.getElementById('score').textContent = score;
        }

        function activarEscudo() {
            if (hasShield) return;
            hasShield = true;
            
            // Crear un escudo visual
            const shieldGeometry = new THREE.SphereGeometry(1.2, 16, 16);
            const shieldMaterial = new THREE.MeshBasicMaterial({
                color: 0x0066FF,
                transparent: true,
                opacity: 0.5,
                wireframe: true
            });
            shieldMesh = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shieldMesh.position.copy(nave.position);
            scene.add(shieldMesh);

            setTimeout(() => {
                hasShield = false;
                if (shieldMesh) {
                    scene.remove(shieldMesh);
                    shieldMesh = null;
                }
            }, 10000); // 10 segundos
        }

        function activarDisparoRapido() {
            if (isRapidFire) return;
            isRapidFire = true;
            const originalSpeed = proyectilSpeed;
            proyectilSpeed = 1.0; // Disparo más rápido

            // Configurar disparo automático
            rapidFireInterval = setInterval(dispararProyectil, 200);

            setTimeout(() => {
                isRapidFire = false;
                proyectilSpeed = originalSpeed;
                if (rapidFireInterval) {
                    clearInterval(rapidFireInterval);
                    rapidFireInterval = null;
                }
            }, 5000); // Dura 5 segundos
        }

        function iniciarJuego() {
            animate();
        }

        function spawnMeteorito() {
            cargarMeteorito();
            cargarMeteorito2();
        }

        function updateGame(currentTime) {
            if (gameOver) return;

            moverNave();
            
            // Mover y actualizar el escudo si existe
            if (shieldMesh && nave) {
                shieldMesh.position.copy(nave.position);
            }

            // Generar nuevos meteoritos
            if (currentTime - lastSpawnTime > spawnInterval) {
                spawnMeteorito();
                lastSpawnTime = currentTime;

                // Aumentar dificultad
                if (spawnInterval > 800) {
                    spawnInterval -= 50;
                }
                if (meteoritoSpeed < 0.15) {
                    meteoritoSpeed += 0.002;
                }
            }

            // Animar power-ups
            powerups.forEach(powerup => {
                // Flotación suave
                powerup.position.y = powerup.userData.originalY + Math.sin(currentTime * 0.001 + powerup.userData.floatOffset) * 0.2;
                
                // Rotación
                powerup.rotation.y += 0.02;
                
                // Parpadeo antes de desaparecer
                if (Date.now() - powerup.userData.tiempoRecogida > 8000) {
                    powerup.material.opacity = 0.5 + 0.4 * Math.sin(currentTime * 0.02);
                }
            });

            // Mover meteoritos
            for (let i = meteoritos.length - 1; i >= 0; i--) {
                const meteorito = meteoritos[i];
                const dir = meteorito.userData.direction;

                meteorito.position.x += dir.x * meteorito.userData.speed;
                meteorito.position.z += dir.z * meteorito.userData.speed;

                // Rotar meteorito
                meteorito.rotation.x += 0.01;
                meteorito.rotation.z += 0.01;

                // Detectar colisiones con la nave
                const distance = Math.sqrt(
                    Math.pow(meteorito.position.x - nave.position.x, 2) +
                    Math.pow(meteorito.position.z - nave.position.z, 2)
                );

                if (distance < 1.0) {
                    // Colisión detectada
                    scene.remove(meteorito);
                    meteoritos.splice(i, 1);
                    
                    // Solo perder vida si no hay escudo activo
                    if (!hasShield) {
                        lives--;
                        document.getElementById('lives').textContent = lives;

                        if (lives <= 0) {
                            gameOver = true;
                            const gameOverText = document.createElement('div');
                            gameOverText.className = 'loading';
                            gameOverText.textContent = '¡Juego terminado! Puntuación: ' + score;
                            document.body.appendChild(gameOverText);
                        }
                    }
                }

                // Eliminar meteoritos que pasaron el centro
                const centerDistance = Math.sqrt(
                    Math.pow(meteorito.position.x, 2) +
                    Math.pow(meteorito.position.z, 2)
                );

                if (centerDistance < 0.5) {
                    scene.remove(meteorito);
                    meteoritos.splice(i, 1);
                }
            }

            // Actualizar proyectiles
            for (let i = proyectiles.length - 1; i >= 0; i--) {
                const proyectil = proyectiles[i];

                // Mover proyectil
                proyectil.position.add(proyectil.userData.direction.clone().multiplyScalar(proyectil.userData.speed));

                // Eliminar proyectiles que se salen del área de juego
                if (Math.abs(proyectil.position.x) > 15 || Math.abs(proyectil.position.z) > 15) {
                    scene.remove(proyectil);
                    proyectiles.splice(i, 1);
                    continue;
                }

                // Detectar colisiones con meteoritos
                for (let j = meteoritos.length - 1; j >= 0; j--) {
                    const meteorito = meteoritos[j];
                    const distance = proyectil.position.distanceTo(meteorito.position);

                    if (distance < 0.7) {
                        // Remover meteorito y proyectil
                        scene.remove(meteorito);
                        meteoritos.splice(j, 1);

                        scene.remove(proyectil);
                        proyectiles.splice(i, 1);

                        // Incrementar puntuación
                        score++;
                        document.getElementById('score').textContent = score;

                        break;
                    }
                }
            }

            // Detectar colisiones con power-ups
            detectarColisionPowerUps();
        }

        // Controlar la nave con teclado
        function onKeyDown(event) {
            if (event.code === 'ArrowLeft') keysPressed.ArrowLeft = true;
            if (event.code === 'ArrowRight') keysPressed.ArrowRight = true;
            if (event.code === 'ArrowUp') keysPressed.ArrowUp = true;
            if (event.code === 'ArrowDown') keysPressed.ArrowDown = true;
            if (event.code === 'Space') dispararProyectil();
        }

        function onKeyUp(event) {
            if (event.code === 'ArrowLeft') keysPressed.ArrowLeft = false;
            if (event.code === 'ArrowRight') keysPressed.ArrowRight = false;
            if (event.code === 'ArrowUp') keysPressed.ArrowUp = false;
            if (event.code === 'ArrowDown') keysPressed.ArrowDown = false;
        }

        function moverNave() {
            if (!nave) return;

            const speed = 0.1;

            if (keysPressed.ArrowLeft) {
                nave.position.x -= speed;
                if (nave.position.x < -9) nave.position.x = -9;
            }
            if (keysPressed.ArrowRight) {
                nave.position.x += speed;
                if (nave.position.x > 9) nave.position.x = 9;
            }
            if (keysPressed.ArrowUp) {
                nave.position.z -= speed;
                if (nave.position.z < -6) nave.position.z = -6;
            }
            if (keysPressed.ArrowDown) {
                nave.position.z += speed;
                if (nave.position.z > 6) nave.position.z = 6;
            }
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = 15;

            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate(currentTime = 0) {
            requestAnimationFrame(animate);
            updateGame(currentTime);
            renderer.render(scene, camera);
        }

        window.onload = initGame;
    </script>
</body>
</html>